"""
Template manager for code generation.

This module provides template management for generating consistent,
production-ready integration code with proper structure and patterns.
"""

from pathlib import Path
from typing import Any, Dict, List, Optional
from dataclasses import dataclass
from jinja2 import Environment, FileSystemLoader, Template

from app.core.logging import LoggerMixin
from app.core.exceptions import ValidationError


@dataclass
class CodeTemplate:
    """Represents a code template."""
    
    id: str
    name: str
    language: str
    category: str
    template_content: str
    variables: List[str]
    description: str
    example_usage: Optional[str] = None
    
    def render(self, variables: Dict[str, Any]) -> str:
        """Render template with variables."""
        template = Template(self.template_content)
        return template.render(**variables)


class TemplateManager(LoggerMixin):
    """
    Manages code templates for integration generation.
    
    Provides template storage, retrieval, and rendering capabilities
    for consistent code generation across different integration types.
    """
    
    def __init__(self, templates_dir: Optional[Path] = None):
        """
        Initialize template manager.
        
        Args:
            templates_dir: Directory containing template files
        """
        self.templates_dir = templates_dir or Path(__file__).parent / "templates"
        self.templates_dir.mkdir(exist_ok=True)
        
        # Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            trim_blocks=True,
            lstrip_blocks=True,
            autoescape=False
        )
        
        # Template storage
        self._templates: Dict[str, CodeTemplate] = {}
        
        # Load default templates
        self._load_default_templates()
    
    def _load_default_templates(self) -> None:
        """Load default code templates."""
        
        # Python async integration template
        python_async_template = CodeTemplate(
            id="python_async_integration",
            name="Python Async Integration",
            language="python",
            category="integration",
            description="Production-ready async Python integration template",
            variables=[
                "integration_name", "source_system", "target_system",
                "data_mappings", "error_handling", "logging_config"
            ],
            template_content='''"""
{{ integration_name }} - Async Integration
Generated by Agentic Integration Platform

This module provides async integration between {{ source_system.name }} and {{ target_system.name }}.
"""

import asyncio
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass
from contextlib import asynccontextmanager

import httpx
from pydantic import BaseModel, Field, field_validator
import structlog

# Configure structured logging
logger = structlog.get_logger(__name__)


class {{ integration_name }}Config(BaseModel):
    """Configuration for {{ integration_name }} integration."""
    
    source_base_url: str = Field(..., description="Source system base URL")
    target_base_url: str = Field(..., description="Target system base URL")
    source_api_key: str = Field(..., description="Source system API key")
    target_api_key: str = Field(..., description="Target system API key")
    timeout_seconds: int = Field(default=30, description="Request timeout")
    retry_attempts: int = Field(default=3, description="Number of retry attempts")
    batch_size: int = Field(default=100, description="Batch processing size")


class IntegrationError(Exception):
    """Custom exception for integration errors."""
    
    def __init__(self, message: str, error_code: str = None, context: Dict[str, Any] = None):
        super().__init__(message)
        self.error_code = error_code
        self.context = context or {}


class {{ integration_name }}Service:
    """
    Service for {{ integration_name }} integration.
    
    Handles data synchronization between {{ source_system.name }} and {{ target_system.name }}
    with proper error handling, retry logic, and logging.
    """
    
    def __init__(self, config: {{ integration_name }}Config):
        """Initialize the integration service."""
        self.config = config
        self._source_client: Optional[httpx.AsyncClient] = None
        self._target_client: Optional[httpx.AsyncClient] = None
    
    @asynccontextmanager
    async def _get_clients(self):
        """Get HTTP clients with proper cleanup."""
        async with httpx.AsyncClient(
            base_url=self.config.source_base_url,
            timeout=self.config.timeout_seconds,
            headers={"Authorization": f"Bearer {self.config.source_api_key}"}
        ) as source_client, httpx.AsyncClient(
            base_url=self.config.target_base_url,
            timeout=self.config.timeout_seconds,
            headers={"Authorization": f"Bearer {self.config.target_api_key}"}
        ) as target_client:
            yield source_client, target_client
    
    async def sync_data(self, data_filter: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Synchronize data between systems.
        
        Args:
            data_filter: Optional filter for data selection
            
        Returns:
            Dict[str, Any]: Synchronization results
        """
        start_time = datetime.utcnow()
        
        try:
            logger.info("Starting data synchronization", filter=data_filter)
            
            async with self._get_clients() as (source_client, target_client):
                # Fetch data from source
                source_data = await self._fetch_source_data(source_client, data_filter)
                
                # Transform data
                transformed_data = await self._transform_data(source_data)
                
                # Send to target
                results = await self._send_to_target(target_client, transformed_data)
            
            duration = (datetime.utcnow() - start_time).total_seconds()
            
            logger.info(
                "Data synchronization completed",
                duration_seconds=duration,
                records_processed=len(results.get("processed", [])),
                errors=len(results.get("errors", []))
            )
            
            return {
                "success": True,
                "duration_seconds": duration,
                "records_processed": len(results.get("processed", [])),
                "errors": results.get("errors", []),
                "summary": results
            }
            
        except Exception as e:
            duration = (datetime.utcnow() - start_time).total_seconds()
            
            logger.error(
                "Data synchronization failed",
                error=str(e),
                duration_seconds=duration,
                exc_info=True
            )
            
            raise IntegrationError(
                f"Synchronization failed: {str(e)}",
                error_code="SYNC_FAILED",
                context={"duration_seconds": duration, "filter": data_filter}
            )
    
    async def _fetch_source_data(
        self,
        client: httpx.AsyncClient,
        data_filter: Optional[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Fetch data from source system."""
        try:
            params = data_filter or {}
            response = await client.get("/api/data", params=params)
            response.raise_for_status()
            
            data = response.json()
            logger.debug(f"Fetched {len(data)} records from source")
            
            return data
            
        except httpx.HTTPError as e:
            raise IntegrationError(
                f"Failed to fetch source data: {str(e)}",
                error_code="SOURCE_FETCH_FAILED"
            )
    
    async def _transform_data(self, source_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Transform data for target system."""
        transformed = []
        
        for record in source_data:
            try:
                # Apply data transformations
                transformed_record = {
{% for mapping in data_mappings %}
                    "{{ mapping.target_field }}": record.get("{{ mapping.source_field }}"){% if mapping.transformation %} {{ mapping.transformation }}{% endif %},
{% endfor %}
                }
                
                # Validate transformed record
                if self._validate_record(transformed_record):
                    transformed.append(transformed_record)
                else:
                    logger.warning("Record validation failed", record=record)
                    
            except Exception as e:
                logger.error(
                    "Record transformation failed",
                    record=record,
                    error=str(e)
                )
        
        logger.debug(f"Transformed {len(transformed)} records")
        return transformed
    
    def _validate_record(self, record: Dict[str, Any]) -> bool:
        """Validate transformed record."""
        # Add validation logic here
        required_fields = ["id"]  # Customize based on requirements
        
        for field in required_fields:
            if field not in record or record[field] is None:
                return False
        
        return True
    
    async def _send_to_target(
        self,
        client: httpx.AsyncClient,
        data: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Send data to target system."""
        results = {"processed": [], "errors": []}
        
        # Process in batches
        for i in range(0, len(data), self.config.batch_size):
            batch = data[i:i + self.config.batch_size]
            
            try:
                response = await client.post("/api/data", json=batch)
                response.raise_for_status()
                
                batch_results = response.json()
                results["processed"].extend(batch_results.get("created", []))
                
                logger.debug(f"Processed batch of {len(batch)} records")
                
            except httpx.HTTPError as e:
                error_info = {
                    "batch_index": i // self.config.batch_size,
                    "error": str(e),
                    "records": batch
                }
                results["errors"].append(error_info)
                
                logger.error(
                    "Batch processing failed",
                    batch_index=i // self.config.batch_size,
                    error=str(e)
                )
        
        return results
    
    async def health_check(self) -> Dict[str, Any]:
        """Check health of both systems."""
        health_status = {
            "source_system": {"healthy": False, "response_time_ms": None},
            "target_system": {"healthy": False, "response_time_ms": None}
        }
        
        async with self._get_clients() as (source_client, target_client):
            # Check source system
            try:
                start_time = datetime.utcnow()
                response = await source_client.get("/health")
                response.raise_for_status()
                
                response_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                health_status["source_system"] = {
                    "healthy": True,
                    "response_time_ms": response_time
                }
                
            except Exception as e:
                logger.warning(f"Source system health check failed: {e}")
            
            # Check target system
            try:
                start_time = datetime.utcnow()
                response = await target_client.get("/health")
                response.raise_for_status()
                
                response_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                health_status["target_system"] = {
                    "healthy": True,
                    "response_time_ms": response_time
                }
                
            except Exception as e:
                logger.warning(f"Target system health check failed: {e}")
        
        return health_status


async def main():
    """Main function for testing the integration."""
    config = {{ integration_name }}Config(
        source_base_url="https://api.source.com",
        target_base_url="https://api.target.com",
        source_api_key="your-source-api-key",
        target_api_key="your-target-api-key"
    )
    
    service = {{ integration_name }}Service(config)
    
    try:
        # Health check
        health = await service.health_check()
        print(f"Health check: {health}")
        
        # Sync data
        results = await service.sync_data()
        print(f"Sync results: {results}")
        
    except IntegrationError as e:
        print(f"Integration error: {e}")
        print(f"Error code: {e.error_code}")
        print(f"Context: {e.context}")


if __name__ == "__main__":
    asyncio.run(main())
''',
            example_usage="""
config = MyIntegrationConfig(
    source_base_url="https://api.source.com",
    target_base_url="https://api.target.com",
    source_api_key="key1",
    target_api_key="key2"
)

service = MyIntegrationService(config)
results = await service.sync_data()
"""
        )
        
        self._templates[python_async_template.id] = python_async_template
        
        # Add more templates here...
        
        self.logger.info(f"Loaded {len(self._templates)} default templates")
    
    def get_template(self, template_id: str) -> Optional[CodeTemplate]:
        """Get template by ID."""
        return self._templates.get(template_id)
    
    def list_templates(
        self,
        language: Optional[str] = None,
        category: Optional[str] = None
    ) -> List[CodeTemplate]:
        """List available templates."""
        templates = list(self._templates.values())
        
        if language:
            templates = [t for t in templates if t.language == language]
        
        if category:
            templates = [t for t in templates if t.category == category]
        
        return templates
    
    def render_template(
        self,
        template_id: str,
        variables: Dict[str, Any]
    ) -> str:
        """Render template with variables."""
        template = self.get_template(template_id)
        
        if not template:
            raise ValidationError(f"Template not found: {template_id}")
        
        try:
            return template.render(variables)
        except Exception as e:
            raise ValidationError(
                f"Template rendering failed: {str(e)}",
                context={"template_id": template_id, "variables": list(variables.keys())}
            )
    
    def add_template(self, template: CodeTemplate) -> None:
        """Add a new template."""
        self._templates[template.id] = template
        self.logger.info(f"Added template: {template.id}")
    
    def get_template_variables(self, template_id: str) -> List[str]:
        """Get required variables for a template."""
        template = self.get_template(template_id)
        return template.variables if template else []
    
    def validate_template_variables(
        self,
        template_id: str,
        variables: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Validate template variables."""
        template = self.get_template(template_id)
        
        if not template:
            return {"valid": False, "error": f"Template not found: {template_id}"}
        
        missing_vars = []
        for var in template.variables:
            if var not in variables:
                missing_vars.append(var)
        
        return {
            "valid": len(missing_vars) == 0,
            "missing_variables": missing_vars,
            "provided_variables": list(variables.keys()),
            "required_variables": template.variables
        }


# Global template manager instance
template_manager = TemplateManager()
